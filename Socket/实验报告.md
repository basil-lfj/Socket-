# Socket网络编程实验报告

## 各文件功能说明

### 1. Server.java - 服务器主程序
**文件路径：** [`Server.java`](Server.java:1)
**代码行数：** 94行

**主要功能：**
- 服务器程序的入口，负责启动整个服务器系统
- 实现端口号验证：[`isValidPort()`](Server.java:11)方法检查端口是否在0-65535范围内
- 支持两种启动方式：
  - 命令行参数：`java Server [端口号]`
  - 交互式输入：提示用户输入端口号
- 创建[`ServerSocket`](Server.java:52)监听指定端口，等待客户端连接
- 为每个连接的客户端创建独立的[`ClientHandler`](ClientHandler.java:4)线程
- 启动[`Listener`](Listener.java:4)线程处理服务器控制台命令
- 维护在线客户端列表：[`ClientList`](Server.java:7)，使用线程安全的`Collections.synchronizedList()`
- 实现[`sendToClient()`](Server.java:76)方法，统一向客户端发送文本消息和文件
- 错误处理：
  - 端口格式错误：捕获`NumberFormatException`，提示"端口号格式不正确"
  - 端口范围错误：提示"端口号必须在0-65535范围内"
  - 端口被占用：捕获`IOException`，提示"服务器启动失败"

**核心代码：**
```java
// 验证端口号
private static boolean isValidPort(int port) {
    return port >= 0 && port <= 65535;
}

// 创建服务器Socket并监听
ServerSocket server = new ServerSocket(port);
Socket client = server.accept();

// 为每个客户端创建处理线程
ClientHandler handler = new ClientHandler(client, ClientCount);
ClientList.add(handler);
handler.start();
```

---

### 2. Client.java - 客户端主程序
**文件路径：** [`Client.java`](Client.java:1)
**代码行数：** 210行

**主要功能：**
- 客户端程序的入口，负责连接到服务器
- 实现IP地址验证：[`isValidIP()`](Client.java:14)方法验证IPv4格式和localhost
- 实现端口号验证：[`isValidPort()`](Client.java:9)方法检查端口是否在0-65535范围内
- 实现IP可达性检查：[`isIPReachable()`](Client.java:41)方法检查IP是否可达（3秒超时）
- 支持两种启动方式：
  - 命令行参数：`java Client [IP地址] [端口号]`
  - 交互式输入：提示用户输入IP地址和端口号
- 创建[`Socket`](Client.java:119)连接到指定服务器
- 启动[`ServerHandler`](ServerHandler.java:4)线程接收服务器消息
- 实现消息发送循环：支持普通文本消息和文件传输
- 实现[`sendFile()`](Client.java:171)方法：读取文件内容并发送到服务器
- 错误处理：
  - IP格式错误：提示"IP地址格式不正确"
  - 端口格式错误：提示"端口号格式不正确"
  - 端口范围错误：提示"端口号必须在0-65535范围内"
  - IP不可达：提示"无法连接到IP地址"
  - 无法解析主机：捕获`UnknownHostException`
  - 连接失败：捕获`ConnectException`
  - 其他IO错误：捕获`IOException`

**核心代码：**
```java
// 验证IP地址
private static boolean isValidIP(String ip) {
    if (ip.equalsIgnoreCase("localhost")) return true;
    String[] parts = ip.split("\\.");
    if (parts.length != 4) return false;
    // 验证每个部分是否在0-255范围内
    for (String part : parts) {
        int num = Integer.parseInt(part);
        if (num < 0 || num > 255) return false;
    }
    return true;
}

// 检查IP可达性
private static boolean isIPReachable(String host) {
    InetAddress address = InetAddress.getByName(host);
    return address.isReachable(3000);
}

// 连接到服务器
Socket socket = new Socket(host, port);

// 发送文件
private static void sendFile(DataOutputStream dos, String filename) {
    File file = new File(filename);
    dos.writeUTF("[FILE] " + filename);
    // 读取并发送文件内容
    dos.writeUTF("[FILE_END]");
}
```

---

### 3. ClientHandler.java - 客户端处理线程
**文件路径：** [`ClientHandler.java`](ClientHandler.java:1)
**代码行数：** 61行

**主要功能：**
- 继承`Thread`类，为每个客户端创建独立的处理线程
- 接收客户端发送的消息和文件
- 发送欢迎信息给新连接的客户端
- 识别并处理不同类型的数据：
  - 普通文本消息：直接显示
  - 文件传输：识别`[FILE]`和`[FILE_END]`标记，收集并显示文件内容
- 维护客户端连接状态，处理客户端断开连接
- 使用[`DataInputStream`](ClientHandler.java:21)读取客户端数据
- 自动从服务器客户端列表中移除断开连接的客户端

**核心代码：**
```java
@Override
public void run() {
    DataInputStream dis = new DataInputStream(socket.getInputStream());
    // 发送欢迎信息
    Server.sendToClient(this, 0, "-t", "Welcome! Your ID is " + num, "UTF-8");
    
    String input;
    boolean receivingFile = false;
    StringBuilder fileContent = new StringBuilder();
    
    while ((input = dis.readUTF()) != null) {
        if (input.startsWith("[FILE] ")) {
            // 开始接收文件
            receivingFile = true;
            currentFilename = input.substring(7);
        } else if (input.equals("[FILE_END]")) {
            // 文件接收完成
            receivingFile = false;
            System.out.println(fileContent.toString());
        } else if (receivingFile) {
            // 接收文件内容
            fileContent.append(input);
        } else {
            // 普通消息
            System.out.println(">> Client " + num + " sent: " + input);
        }
    }
}
```

---

### 4. ServerHandler.java - 服务器消息接收线程
**文件路径：** [`ServerHandler.java`](ServerHandler.java:1)
**代码行数：** 26行

**主要功能：**
- 继承`Thread`类，为客户端创建独立的接收线程
- 专门负责接收服务器发送的消息
- 使用[`DataInputStream`](ServerHandler.java:14)读取服务器数据
- 实时显示服务器发来的消息
- 处理连接断开情况：
  - 正常断开：捕获`EOFException`
  - 异常断开：捕获`IOException`

**核心代码：**
```java
@Override
public void run() {
    DataInputStream dis = new DataInputStream(socket.getInputStream());
    String line;
    while ((line = dis.readUTF()) != null) {
        System.out.print(line);
        System.out.print(">> ");
    }
}
```

---

### 5. Listener.java - 服务器控制台监听器
**文件路径：** [`Listener.java`](Listener.java:1)
**代码行数：** 47行

**主要功能：**
- 实现`Runnable`接口，作为服务器控制台命令的监听线程
- 读取服务器控制台输入，解析并执行命令
- 支持的命令：
  - `-l`：查看在线客户端列表，显示所有连接的客户端ID
  - `-c <id> -t <msg>`：向指定ID的客户端发送私聊消息
  - `exit`：退出服务器程序
- 命令格式验证和错误处理：
  - ID格式错误：提示"ID必须是数字"
  - 命令格式错误：提示"命令格式应为 -c <id> -t <msg>"
  - 未知命令：提示可用命令列表
- 使用`synchronized`确保线程安全地访问客户端列表

**核心代码：**
```java
public void run() {
    Scanner sc = new Scanner(System.in);
    while (true) {
        String cmd = sc.nextLine();
        String[] parts = cmd.split(" ");
        
        if (parts[0].equals("-l")) {
            // 查看在线列表
            synchronized (list) {
                for (ClientHandler h : list) {
                    System.out.println("Online: ID " + h.getNum());
                }
            }
        } else if (parts[0].equals("-c")) {
            // 私聊: -c <id> -t <msg>
            int targetId = Integer.parseInt(parts[1]);
            synchronized (list) {
                for (ClientHandler h : list) {
                    if (h.getNum() == targetId) {
                        Server.sendToClient(h, 0, parts[2], parts[3], fileEncoding);
                    }
                }
            }
        } else if (parts[0].equals("exit")) {
            // 退出服务器
            System.exit(0);
        }
    }
}
```

---

### 文件关系图
```
                    ┌─────────────────┐
                    │   Server.java   │
                    │   (主服务器)    │
                    └────────┬────────┘
                             │
              ┌──────────────┼──────────────┐
              │              │              │
              ▼              ▼              ▼
    ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
    │  Listener.java  │ │ ClientHandler 1 │ │ ClientHandler 2 │
    │  (控制台监听)   │ │  (客户端线程1)  │ │  (客户端线程2)  │
    └─────────────────┘ └────────┬────────┘ └────────┬────────┘
                             │                   │
                    ┌────────┴────────┐  ┌────────┴────────┐
                    │                 │  │                 │
                    ▼                 ▼  ▼                 ▼
           ┌───────────────┐  ┌───────────────┐  ┌───────────────┐
           │   Client 1    │  │   Client 2    │  │   Client 3    │
           │  ServerHandler│  │  ServerHandler│  │  ServerHandler│
           └───────────────┘  └───────────────┘  └───────────────┘
```

---

## 一、实验内容和步骤

### 1.1 实验目的
本实验旨在通过Java Socket编程实现一个基于TCP协议的客户端-服务器通信系统，掌握网络编程的基本原理和方法，理解多线程在网络通信中的应用，并实现完善的错误处理机制。

### 1.2 实验环境
- **操作系统**：Windows 11
- **开发工具**：VS Code
- **编程语言**：Java
- **网络协议**：TCP/IP
- **默认端口**：8080

### 1.3 实验内容
本实验实现了一个支持多客户端连接的聊天系统，具有以下功能：

#### 1.3.1 服务器端功能
- 监听指定端口，等待客户端连接
- 支持多客户端同时连接，为每个客户端分配独立ID
- 接收并显示客户端发送的消息
- 接收并显示客户端发送的文件内容
- 提供服务器控制台命令：
  - `-l`：查看在线客户端列表
  - `-c <id> -t <msg>`：向指定客户端发送消息
  - `exit`：退出服务器
- 端口输入验证：检查端口格式和范围（0-65535）
- 连接错误处理：端口被占用时的错误提示

#### 1.3.2 客户端功能
- 连接到指定服务器（支持IP地址和localhost）
- 发送文本消息到服务器
- 发送文件到服务器
- 接收并显示服务器发来的消息
- 支持命令行参数启动（IP地址和端口号）
- 交互式输入（IP地址和端口号）
- IP地址格式验证（IPv4格式）
- 端口号格式和范围验证（0-65535）
- IP地址可达性检查（非localhost连接时）
- 连接错误处理：
  - IP地址不可达
  - 无法解析主机地址
  - 无法连接到服务器
  - 其他网络连接错误

### 1.4 实验步骤

#### 步骤1：服务器端程序开发
1. 创建[`Server.java`](Server.java:1)主程序类
2. 实现[`isValidPort()`](Server.java:11)方法验证端口号范围
3. 实现端口输入逻辑，支持命令行参数和交互式输入
4. 添加端口格式和范围验证，错误时显示提示并退出
5. 创建[`ServerSocket`](Server.java:52)监听指定端口
6. 实现循环接收客户端连接
7. 为每个客户端创建[`ClientHandler`](ClientHandler.java:4)线程
8. 启动[`Listener`](Listener.java:4)线程处理服务器控制台命令
9. 实现[`sendToClient()`](Server.java:76)方法统一发送消息和文件

#### 步骤2：客户端程序开发
1. 创建[`Client.java`](Client.java:1)主程序类
2. 实现[`isValidPort()`](Client.java:9)方法验证端口号范围
3. 实现[`isValidIP()`](Client.java:14)方法验证IP地址格式
4. 实现[`isIPReachable()`](Client.java:41)方法检查IP可达性
5. 实现IP和端口输入逻辑，支持命令行参数和交互式输入
6. 添加IP和端口验证，错误时显示提示并退出
7. 创建[`Socket`](Client.java:119)连接到服务器
8. 启动[`ServerHandler`](ServerHandler.java:4)线程接收服务器消息
9. 实现消息发送循环
10. 实现[`sendFile()`](Client.java:171)方法发送文件

#### 步骤3：客户端处理程序开发
1. 创建[`ClientHandler.java`](ClientHandler.java:1)类继承Thread
2. 实现[`run()`](ClientHandler.java:19)方法处理客户端消息
3. 使用[`DataInputStream`](ClientHandler.java:21)读取客户端消息
4. 发送欢迎信息给客户端
5. 识别并处理文件传输（`[FILE]`和`[FILE_END]`标记）
6. 处理普通文本消息
7. 实现异常处理和连接断开清理

#### 步骤4：服务器处理程序开发
1. 创建[`ServerHandler.java`](ServerHandler.java:1)类继承Thread
2. 实现[`run()`](ServerHandler.java:12)方法接收服务器消息
3. 使用[`DataInputStream`](ServerHandler.java:14)读取服务器消息
4. 打印接收到的消息
5. 实现异常处理

#### 步骤5：监听器程序开发
1. 创建[`Listener.java`](Listener.java:1)类实现Runnable
2. 实现[`run()`](Listener.java:10)方法处理控制台输入
3. 实现`-l`命令查看在线客户端列表
4. 实现`-c <id> -t <msg>`命令发送私聊消息
5. 实现`exit`命令退出服务器
6. 添加命令格式验证和错误处理

#### 步骤6：编译和测试
1. 编译所有Java文件：`javac *.java`
2. 启动服务器：`java Server [端口]`
3. 启动客户端：`java Client [IP地址] [端口]`
4. 测试多客户端连接
5. 测试消息发送
6. 测试文件传输
7. 测试错误处理（错误端口、错误IP、不可达IP等）

---

## 二、实验过程与分析

### 2.1 系统架构分析

本系统采用经典的客户端-服务器（Client-Server）架构，基于TCP协议实现可靠的网络通信。系统架构如图所示：

```
                    ┌─────────────────┐
                    │   Server.java   │
                    │   (主服务器)    │
                    └────────┬────────┘
                             │
              ┌──────────────┼──────────────┐
              │              │              │
              ▼              ▼              ▼
    ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
    │  Listener.java  │ │ ClientHandler 1 │ │ ClientHandler 2 │
    │  (控制台监听)   │ │  (客户端线程1)  │ │  (客户端线程2)  │
    └─────────────────┘ └─────────────────┘ └─────────────────┘
                             │
                    ┌────────┴────────┐
                    │                 │
                    ▼                 ▼
           ┌───────────────┐  ┌───────────────┐
           │   Client 1    │  │   Client 2    │
           │  ServerHandler│  │  ServerHandler│
           └───────────────┘  └───────────────┘
```

### 2.2 关键技术分析

#### 2.2.1 Socket通信机制
系统使用Java的[`Socket`](Client.java:119)和[`ServerSocket`](Server.java:52)类实现TCP通信：

- **ServerSocket**：在服务器端创建，绑定指定端口，监听客户端连接请求
- **Socket**：在客户端创建，连接到服务器的IP地址和端口
- **数据流**：使用[`DataInputStream`](ClientHandler.java:21)和[`DataOutputStream`](Client.java:125)进行数据的读写，支持UTF编码

#### 2.2.2 多线程并发处理
系统采用多线程技术实现多客户端并发连接：

- **服务器端**：每个客户端连接创建一个独立的[`ClientHandler`](ClientHandler.java:4)线程
- **客户端**：创建独立的[`ServerHandler`](ServerHandler.java:4)线程接收服务器消息
- **服务器控制台**：独立的[`Listener`](Listener.java:4)线程处理服务器命令
- **线程安全**：使用[`Collections.synchronizedList()`](Server.java:7)创建线程安全的客户端列表

#### 2.2.3 数据传输协议
系统定义了简单的数据传输协议：

- **文本消息**：直接使用`writeUTF()`发送文本内容
- **文件传输**：
  - 文件开始标记：`[FILE] 文件名`
  - 文件内容：分块发送文件内容
  - 文件结束标记：`[FILE_END]`

#### 2.2.4 错误处理机制
系统实现了完善的错误处理机制：

**服务器端错误处理：**
- 端口格式验证：使用[`Integer.parseInt()`](Server.java:22)解析端口，捕获`NumberFormatException`
- 端口范围验证：使用[`isValidPort()`](Server.java:11)检查端口是否在0-65535范围内
- 连接错误处理：捕获`IOException`，提示端口被占用

**客户端错误处理：**
- IP地址格式验证：使用[`isValidIP()`](Client.java:14)验证IPv4格式和localhost
- 端口格式验证：使用[`Integer.parseInt()`](Client.java:66)解析端口，捕获`NumberFormatException`
- 端口范围验证：使用[`isValidPort()`](Client.java:9)检查端口是否在0-65535范围内
- IP可达性检查：使用[`isIPReachable()`](Client.java:41)检查IP是否可达（3秒超时）
- 连接错误处理：
  - `UnknownHostException`：无法解析主机地址
  - `ConnectException`：无法连接到服务器
  - `IOException`：其他网络连接错误

### 2.3 实验过程记录

#### 2.3.1 服务器启动测试
**测试1：默认端口启动**
```
命令：java Server
输入：（直接回车，使用默认端口8080）
结果：服务器成功启动，显示 "Server started on port 8080..."
```

**测试2：指定端口启动**
```
命令：java Server 9000
结果：服务器成功启动，显示 "Server started on port 9000..."
```

**测试3：错误端口格式**
```
命令：java Server abc
结果：显示 "错误：端口号格式不正确，请输入有效的数字" 并退出
```

**测试4：端口超出范围**
```
命令：java Server 70000
结果：显示 "错误：端口号必须在0-65535范围内" 并退出
```

**测试5：端口被占用**
```
操作：启动两个服务器实例，使用相同端口
结果：第二个服务器显示 "服务器启动失败: Address already in use"
```

#### 2.3.2 客户端连接测试
**测试1：默认连接**
```
命令：java Client
输入：IP地址（直接回车，使用localhost），端口（直接回车，使用8080）
结果：成功连接，显示 "Connected to server!"
```

**测试2：指定IP和端口**
```
命令：java Client 127.0.0.1 9000
结果：成功连接到指定IP和端口
```

**测试3：错误IP格式**
```
命令：java Client 256.256.256.256
结果：显示 "错误：IP地址格式不正确 - 256.256.256.256" 并退出
```

**测试4：错误端口格式**
```
命令：java Client localhost abc
结果：显示 "错误：端口号格式不正确，请输入有效的数字" 并退出
```

**测试5：IP不可达**
```
命令：java Client 192.168.1.999 8080
结果：显示 "错误：无法连接到IP地址 - 192.168.1.999" 并退出
```

**测试6：服务器未启动**
```
操作：客户端尝试连接未启动的服务器
结果：显示 "错误：无法连接到服务器 localhost:8080" 及检查提示
```

#### 2.3.3 多客户端通信测试
**测试场景：**
1. 启动服务器（端口8080）
2. 启动客户端1，分配ID=1
3. 启动客户端2，分配ID=2
4. 客户端1发送消息："Hello from Client 1"
5. 客户端2发送消息："Hello from Client 2"
6. 服务器使用`-l`命令查看在线列表
7. 服务器使用`-c 1 -t Hello from Server`向客户端1发送消息

**测试结果：**
- 所有客户端成功连接
- 服务器正确显示所有客户端消息
- 服务器命令正常工作
- 客户端正确接收服务器消息

#### 2.3.4 文件传输测试
**测试场景：**
1. 创建测试文件`test.txt`，内容："This is a test file."
2. 客户端执行：`/send test.txt`
3. 观察服务器端显示

**测试结果：**
- 客户端显示："正在发送文件: test.txt"
- 客户端显示："文件大小: 21 字节"
- 客户端显示："文件发送完成: test.txt"
- 服务器显示："Client 1 is sending file: test.txt"
- 服务器显示："Client 1 sent file: test.txt"
- 服务器显示文件内容："This is a test file."

### 2.4 问题分析与解决

#### 问题1：端口验证不完善
**问题描述：** 初始版本只检查端口是否为数字，未检查端口范围。

**解决方案：** 添加[`isValidPort()`](Server.java:11)方法，检查端口是否在0-65535范围内。

#### 问题2：IP地址格式验证缺失
**问题描述：** 客户端可以输入任意格式的IP地址，导致连接失败时提示不明确。

**解决方案：** 添加[`isValidIP()`](Client.java:14)方法，验证IPv4格式和localhost。

#### 问题3：IP不可达时无提示
**问题描述：** 客户端尝试连接不可达的IP地址时，等待时间过长且无明确提示。

**解决方案：** 添加[`isIPReachable()`](Client.java:41)方法，在连接前检查IP可达性（3秒超时）。

#### 问题4：错误处理不统一
**问题描述：** 不同类型的连接错误使用相同的错误提示，用户难以定位问题。

**解决方案：** 分别捕获`UnknownHostException`、`ConnectException`和`IOException`，提供针对性的错误提示。

#### 问题5：文件传输无错误处理
**问题描述：** 发送不存在的文件时，程序会抛出异常。

**解决方案：** 在[`sendFile()`](Client.java:171)方法中添加文件存在性检查和错误处理。

---

## 三、实验总结

### 3.1 实验成果
通过本次实验，成功实现了一个功能完善的Socket网络通信系统，具体成果如下：

1. **服务器端程序**：[`Server.java`](Server.java:1)（94行）
   - 支持多客户端并发连接
   - 提供服务器控制台命令
   - 完善的端口验证和错误处理

2. **客户端程序**：[`Client.java`](Client.java:1)（210行）
   - 支持连接到指定服务器
   - 支持消息和文件传输
   - 完善的IP和端口验证
   - 详细的连接错误处理

3. **客户端处理程序**：[`ClientHandler.java`](ClientHandler.java:1)（61行）
   - 独立线程处理每个客户端
   - 支持文本和文件接收
   - 自动清理断开连接

4. **服务器处理程序**：[`ServerHandler.java`](ServerHandler.java:1)（26行）
   - 独立线程接收服务器消息
   - 实时显示服务器消息

5. **监听器程序**：[`Listener.java`](Listener.java:1)（47行）
   - 处理服务器控制台命令
   - 支持在线列表查看和私聊

### 3.2 技术收获

#### 3.2.1 网络编程基础
- 掌握了TCP/IP协议的基本原理
- 理解了Socket和ServerSocket的使用方法
- 学会了使用DataInputStream和DataOutputStream进行数据传输

#### 3.2.2 多线程编程
- 理解了多线程在网络编程中的应用
- 掌握了Thread类的使用方法
- 学会了使用synchronized实现线程安全

#### 3.2.3 错误处理
- 掌握了Java异常处理机制
- 学会了针对不同异常类型提供不同的错误提示
- 理解了输入验证的重要性

#### 3.2.4 协议设计
- 学会了设计简单的数据传输协议
- 理解了协议标记的作用（如`[FILE]`和`[FILE_END]`）
- 掌握了文件传输的基本方法

### 3.3 实验心得

1. **错误处理的重要性**：在网络编程中，完善的错误处理机制至关重要。用户可能输入各种错误的数据，程序需要能够识别这些错误并提供友好的提示。本实验中，通过添加端口验证、IP验证、可达性检查等，大大提升了程序的健壮性。

2. **多线程的必要性**：在处理多客户端连接时，多线程技术是必不可少的。每个客户端都需要独立的线程来处理，否则一个客户端的阻塞会影响其他客户端的通信。本实验通过为每个客户端创建独立的ClientHandler线程，实现了真正的并发通信。

3. **协议设计的简洁性**：数据传输协议应该尽量简洁明了。本实验使用简单的文本标记（如`[FILE]`）来区分不同类型的数据，这种方式易于理解和实现。

4. **用户体验的考虑**：程序应该提供友好的用户界面和清晰的提示信息。本实验中，通过添加详细的错误提示、操作提示（如"连续按两次回车键退出客户端"），提升了用户体验。

5. **代码的可维护性**：良好的代码结构和命名规范有助于代码的维护。本实验中，将不同功能分离到不同的类中，每个类职责明确，便于理解和维护。


### 3.5 结论
通过本次实验，深入理解了Socket网络编程的原理和方法，掌握了多线程在网络编程中的应用，学会了如何设计一个健壮的网络通信系统。实验过程中遇到的问题和解决方案，为今后的网络编程实践积累了宝贵经验。本实验的成功实现，为后续学习更高级的网络编程技术打下了坚实的基础。
